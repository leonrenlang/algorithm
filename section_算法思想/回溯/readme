# 解决一个回溯问题，实际上就是一个决策树的遍历过程

# 路径：已经做出的选择
# 选择列表：当前可以做出的选择    ------ 还要考虑进行选择后子问题的选择列表，如果与父问题不同，需要使用变量加以限制
# 结束条件：达到决策树的底层，无法再做选择的条件

# 目标是返回一系列满足条件的路径
# 如果遍历到的所有路径均满足条件，则没有优化空间，如果存在大量不满足条件的路径，则可能
# 存在优化空间。


# 如何图形化回溯过程
# - 回溯的过程是可以想象成一棵树，树的每一条路径都对应一个结果

# 递归，回溯，动态规划
# - 动态规划其实就是利用空间优化了的递归方法
# - 回溯是一种特殊的递归问题，它是没有优化的，它的特殊之处在于
    # - 递归是要找到父问题与子问题之间的关系，“返回父问题的解即可”
    # - 而递归需要将父问题的选择和子问题的结果结合起来，作为结果返回，因此需要一个全局变量track
    # 存储运行过程的结果
    # - 如果选择列表种元素的个数的固定且可索引的，那么可以直接用递归


# 框架：
# def backtrack(路径, 选择列表):
#     if 满足结束条件:
#         result.add(路径)
#         return
#
#     for 选择 in 选择列表:
#         做选择
#         backtrack(路径, 选择列表)
#         撤销选择
# result = []
# backtrack(路径， 选择列表）
# return result


def backtrack(路径， 选择列表）：
    if 满足结束条件：
        result.add(路径)
        return
    for 选择 in 选择列表：
        路径.append(选择）
        backtrack(路径， 选择列表）
        路径.remove(选择)
    result = []
    backtrack(路径， 选择列表）
    return result

# 问题2：N皇后问题
# def backtrack(board, row):
#     for col in range(len(board)):
#         if not isValid(board, row, col):
#             continue
#         board[row][col] = "Q"




  哈希函数：
    1.输入域是无限的（f域）
    2.输出域是有穷的（s域）
        比如2^64,16个十六进制数
    3.输入如果一样，输出一定相同(函数都这样)
    4.当输入不一样，有可能得到相同的值(函数都这样)
    5.（精）如果有很多不同的输入的话，将在整个s域均匀的出现其返回值，
        且返回值与原始的输入规律是没有关系的(因此简单取模不是哈希函数)
    推论：
        1. 哈希域一般比较大，将每个input的哈希值mod m(实际使用一般会返回这个m值),哈希函数在这个
        m域上也是均匀分布的。
        2. 当有一个哈希函数时，可以通过以下方法获得1000个相互独立哈希函数。
            h = hash(input)
            h = h1, h2
            h' = h1 + h2*i  (2<=i<=1001)
            （因为哈希函数的每一位也是独立的）
    - 常用哈希算法(指的是哈希函数)
        MD5, SHA1


哈希表: 
    - 哈希表是利用哈希函数构造的一种数据结构
    - 经典哈希表
        增
        - 表长为table_length,   将数据放在 hash(key) mod table_length的位置
        - 例如：对于一个key，将key输入hash函数获取其hash值。假设hash表的表长为16，将hash值mod 16，假如结果为5，结果加到
        hash表中第五个桶中。
        - 如果桶内已经有元素（相同的key，对比其值），则需要处理冲突
        查
        - hash(key) mod table_length
        删
        - 找到相应的键值对，如果是链表形式存储，则保留上一个
        改
        - 找到相应的键值对，修改
        扩容：
        - 因为hash值是均匀分布的，当某个桶内数据(经典结构是一个链表）到达一定数量，认为hash表的效率可能下降，
        - 行扩容。
            关于扩容的时间损耗，如果每次扩容增加一倍，对整个N条数据，需要扩容logn次，数学上不是O(1)
            实际工程中甚至可以离线扩容，扩容完成再替换,则为O(1)
            JVM里面每个桶对应一个红黑树（平衡搜索二叉树）
            开放地址法就是当前桶放不下了，按一定规则放到其他桶里
            增大hash表的表长，对表内的每一个值重新计算hash值，重新放入。
    - 实际使用的时候可以认为哈希表的CRUD都是O(1)
        因为每个桶内的数据量应该非常小

